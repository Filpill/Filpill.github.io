<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Flight Tracking Animations | Filip Livancic</title>
<meta name="keywords" content="üìä Data">
<meta name="description" content="Retrieving airspace states via OpenSky REST API and animating data using Python &#43; FFMPEG">
<meta name="author" content="">
<link rel="canonical" href="https://filpill.github.io/projects/2024-05-21-flight-tracking/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b97b539aa25740381c9dc83f76b08bd5df6cb62b114e54ba5efab1bdfa743666.css" integrity="sha256-uXtTmqJXQDgcncg/drCL1d9stisRTlS6Xvqxvfp0NmY=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://filpill.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://filpill.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://filpill.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://filpill.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://filpill.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://filpill.github.io/projects/2024-05-21-flight-tracking/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Flight Tracking Animations" />
<meta property="og:description" content="Retrieving airspace states via OpenSky REST API and animating data using Python &#43; FFMPEG" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://filpill.github.io/projects/2024-05-21-flight-tracking/" />
<meta property="og:image" content="https://filpill.github.io/img/flight/airspace_visualiser.png" /><meta property="article:section" content="projects" />
<meta property="article:published_time" content="2024-05-26T00:00:00+00:00" />
<meta property="article:modified_time" content="2024-05-26T00:00:00+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://filpill.github.io/img/flight/airspace_visualiser.png" />
<meta name="twitter:title" content="Flight Tracking Animations"/>
<meta name="twitter:description" content="Retrieving airspace states via OpenSky REST API and animating data using Python &#43; FFMPEG"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Projects",
      "item": "https://filpill.github.io/projects/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Flight Tracking Animations",
      "item": "https://filpill.github.io/projects/2024-05-21-flight-tracking/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Flight Tracking Animations",
  "name": "Flight Tracking Animations",
  "description": "Retrieving airspace states via OpenSky REST API and animating data using Python + FFMPEG",
  "keywords": [
    "üìä Data"
  ],
  "articleBody": "üó∫Ô∏è Summary This article will quickly show you the process of obtaining airspace data using the OpenSky REST API and how I was able to visualise on a map. I will focus on North American airspace as it seems this region captures the highest volume of aircraft.\nThe Flight Tracking GitHub Project link is here should you wish to examine my scripts and get some context for the commentary in this article.\nThe totality of the airspace depends on the maintenance of the OpenSky network. The majority of the data is recorded via ADS-B receivers, which are distributed over the land mass.\nRegarding aircraft surveillance, I presume we lose visibility of aircraft (in the data) outside the range of ground stations such as the sea or mountainous terrain. Otherwise it would‚Äôve been interesting to monitor the full extent of flight paths across the globe.\nAircraft require a transponder to retrieve the GPS data i.e. communicating between satellites and ground stations. Any aircraft flying with no transponder are not captured in this view.\nI am sure there are other flight data providers selling more accurate views and more reliable aircraft coverage, but this is purely an illustrative exercise for curiosities sake.\nüí¨ Data Processing Commentary I‚Äôll go through details of my data collection, storage and processing.\nThis was a fairly quick and dirty version, however, I still ensured a reasonable folder structure to manipulate the data in my workflow.\nLong-term we can look at dumping this info into a SQLite or Postgres database.\nüñºÔ∏è Overall View The workflow looks something like this:\ngraph LR; classDef blue fill:#2374f7,stroke:#8ec1f5,stroke-width:7px, color:#fff,stroke-dasharray: 4 1 classDef yellow fill:#e6d00b,stroke:#f5eb5b,stroke-width:7px, color:#000,stroke-dasharray: 4 1 classDef green fill:#10ad0a,stroke:#7feb4d,stroke-width:7px, color:#000,stroke-dasharray: 4 1 classDef red fill:#db3b1f,stroke:#eb654d,stroke-width:7px, color:#fff,stroke-dasharray: 4 1 1([Request aircraft positions]):::blue --o 2([Store raw csv]):::yellow--o3([Process images]):::green--o4([Create Video]):::red linkStyle 0 stroke:#8ec1f5,stroke-width:11px linkStyle 1 stroke:#f5eb5b,stroke-width:11px linkStyle 2 stroke:#7feb4d,stroke-width:11px API Request Every 60s for worldwide airspace snapshots. Data Storage Dumping series of snapshots into timestamped csv‚Äôs. Image Processing Read/prepare/filter data and draw visualisation onto map. Animating Splice image collection with ffmpeg shell script ‚è±Ô∏è Procedural Timings To put some perspective in time required to process this data:\nIt takes about 16 hours to make 850 requests (@60s intervals). It takes about 5-10 mins to create all 850 image visualisations with quiver plot. It takes about 20 hours to create all 850 image visualisations with the KDE plot. I‚Äôm pretty sure the script slowed down over time. I was only removing the quiver artist but not the KDE artist (by omission). Probably too many chart element variables were being stored in the memory over time. Another 4-7 mins to crops all the white space from the images. Splicing images takes about 3-5 ish mins into a neat .mp4. And lastly the video edit takes around 30 mins to overlay music. All in all it roughly takes a full day with the PC running essentially non-stop. And I was manually driving the scripts since I didn‚Äôt build any monitoring tools in this workflow.\nüöú Data Collection The goal here is simple: recursively request and store the aircraft positions in a list of timestamped csv‚Äôs. This is how we will build our data repository.\nWe have to balance the time delta between each snapshot (API call); not too large to lose movement details and not too small to overload the API with requests. The latter is probably more important to consider, because we don‚Äôt want to bombard the API and risk taking it completely out of commission with high frequency requests.\nIt‚Äôs worth noting that that anonymous OpenSky API users are limited to 80 requests per day. This is no good for us since we are trying to make an extended time lapse over a period of time.\nWe can circumvent this issue through IP address rotation. Each API call will be distributed over a pool of IP addresses and thus prevent our request timing out (since they can‚Äôt pin down our real identity).\nThis typically requires the use of a paid service to provide a set of high quality proxies. In my scenario, I chose to use OxyLabs which have a dedicated web scrapping proxy tool. You can route your Python request via the OxyLabs web-scrapping tool and it will automagically handle the proxies for you. I was able to run my script overnight with zero failures and retrieved over 850 requests.\nEach request produces a 1.1MB csv file. Over the course of 16 hours, we were able to hoover about 1GB of data all together. Unfortunately, my script crashed in the late stages of the execution probably because I was running it out of a jupyter notebook and recursively printing output messages. Otherwise we could‚Äôve captured more. I‚Äôll convert it into a Python script eventually, it just so happens its easier to do data exploration in Jupyter.\nYou may notice also that the git history doesn‚Äôt have an extensive list of csv data which because there is no reason to have a volume of csv‚Äôs saved on the git history. Therefore it‚Äôs simply added to the .gitignore and we are storing the files locally for the most part.\nüìä Data Visualisation I think the most interesting component to visualising this type of data is monitoring the density of air traffic at various times of day. Especially in North America where the time zone from east coast to west coast varies by a 6-hour difference. As the country approaches the early hours of the morning, the entire east coast essentially ‚Äúgo to sleep‚Äù with respect to the density of the traffic. Then it flips vice-versa as time progresses.\nAdditionally, we can see commercial flight routes and airport hubs where these flight networks are connecting each other. There is a multitude of ways to visualise this information, all the way from a contourf plot to a quiver plot to some kind of color mesh plot. Alternative 2D visualisations will reveal different information about air traffic behaviour, so it‚Äôs good to compare and contrast.\nAvailable GPS Data sourced from OpenSky API:\nLongitude Latitude Speed Bearing Various other data points including callsigns. For a quiver plot, we need to split the speed into its horizontal and vertical components. We can do some basic trigonometry to figure that out.\nIn the quiver example below, we see the direction and speed (relative to it‚Äôs arrow size) of each individual aircraft. When this data is animated, we can see the arrows get smaller for aircraft on the approach, and grow as they are taking off. It has a very interesting appearance. We also can map this out is by creating a scatter distribution and embed the Gaussian KDE (Kernel Density Estimation) mapping onto the individual points themselves to get a feel for the distribution as there is a lot of overlap at this scale:\nAnd we can map the KDE over the entire map itself, however, we must create a ‚Äúmeshgrid‚Äù over the plot. The aircraft exist between the grids native resolution, therefore we would need to re-shape the data into a 2-dimensional array containing the aircraft density distribution.\nWe can combine the 2D KDE mapping with the quiver plot to reveal a bit more information on aircraft density distribution, like so:\nThe plotting process is iterated over the folder of timestamped csv‚Äôs to generate the incremental aircraft movements over time.\nMap Data Struggles Something that left me completely stumped for a while is that I was not able to directly use the Stadia Maps API within in Cartopy 0.22.0 which was confusing and frustrating.\nI chose to use the Stadia Maps API via the Cartopy as it had already build the classes to plug into the API and it had a high contrast map tile that thought was suitable. But it doesn‚Äôt work on Cartopy 0.22.0‚Ä¶ It really was a head scratcher for me. After reading the site-packages I realised that the API class I was using was completely defunct within a matter of months.\nAlthough, I discovered a revised class object sitting (which works) in Cartopy 0.23.0 which was unavailable as a wheel/conda package. So, this was the first time I had to go build the package from source in the git repo just for this specific use case. But when they eventually package the final version of 0.23.0 in conda, this issue will no longer be the case‚Ä¶\nAlthough I came across some issues since each API call for the mapping data costs credits to use. And since the map is completely static, it doesn‚Äôt make sense to make multiple API calls for each set of data from a cost perspective.\nEven from a time perspective, it takes a very long time to render the map, about 13s for each snapshot which is way too long. Instead, the process I have created is to only clear the relevant ‚Äúartists‚Äù on the matplotlib figure whilst retaining the map image on the plot. So we can save a lot of time.\nPlotting the scatterpoints takes a trivial amount of time in comparison, about 1-2s or so per iteration.\nSlow Color Mesh Plotting Plotting the 2D Gaussian KDE plot was much more intensive as we are drawing a high resolution color mapping across the entire grid. Each iteration was about 20-25s to render but it tended to slow down to over 1m per iteration. The filled color grid mapping took about 20 hours to create all 850 images. Probably because I was not removing the artist itself per iteration, but this is just a working assumption. I‚Äôll have a look at optimising in the future.\nBearing in mind we are purely talking about single core processing. Splitting the load across the rest of the CPU cores, and spawning the data processes in parallel would‚Äôve cut the time significantly. I‚Äôll investigate this setup in the near future to optimise the compute power since Python is pretty slow in general.\n‚úàÔ∏è Data Animation This is the key component where we can physically see how the aircraft are moving over time.\nThis animation procedure is fairly straightforward when using ffmpeg in a bash script. We can point to a folder with a collection of images and ask the program to splice them together into a mp4 file (or whatever file type).\nAssuming the images are timestamped, the files should be sorted in chronological order so you don‚Äôt need to fiddle with passing additional sort arguments into your command.\nIt only takes a few minutes on my machine to splice together 850 images together.\nMy file structure is segmented into multiple folders partitioned by ‚Äúdate‚Äù and ‚Äúvisualisation type‚Äù, I simply pass those parameters into my bash script to generate the spliced video.\nThe script is only a few lines and looks like this:\n#!/bin/sh # $1 Specifies the Date of the folder to be accessed - E.g. '2024-08-24' # $2 Specifies the Image Folder To Be Accessed - E.g. 'scatter' or 'quiver' or 'contourf' # Example of how to run bash script: $(./mkvideo '2024-08-24' 'scatter') base_folder=\"$(dirname $(pwd))\" output=\"$base_folder/animate/videos\" image_data=\"$base_folder/data/get_states/$1/$2/crop\" ffmpeg -framerate 24 -pattern_type glob -i \"${image_data}/*.png\" $output/$1_$2_movements.mp4 Other video processing was down on Kdenlive to add in the musical audio transitions.\nüìΩÔ∏è Data Time-lapse Videos illustrating the 16-hour scatter plot time-lapse of aircraft flying over North America. ",
  "wordCount" : "1875",
  "inLanguage": "en",
  "image":"https://filpill.github.io/img/flight/airspace_visualiser.png","datePublished": "2024-05-26T00:00:00Z",
  "dateModified": "2024-05-26T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://filpill.github.io/projects/2024-05-21-flight-tracking/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Filip Livancic",
    "logo": {
      "@type": "ImageObject",
      "url": "https://filpill.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
<script>mermaid.initialize({ startOnLoad: true, securityLevel: 'loose'}});</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://filpill.github.io/" accesskey="h" title="Filip Livancic (Alt + H)">Filip Livancic</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                <ul class="lang-switch"><li>|</li>
                </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://filpill.github.io/" title="üè† Home">
                    <span>üè† Home</span>
                </a>
            </li>
            <li>
                <a href="https://filpill.github.io/profile/" title="üë§ Profile">
                    <span>üë§ Profile</span>
                </a>
            </li>
            <li>
                <a href="https://filpill.github.io/archives/" title="üìÅ Archive">
                    <span>üìÅ Archive</span>
                </a>
            </li>
            <li>
                <a href="https://filpill.github.io/tags/" title="üè∑Ô∏è Tags">
                    <span>üè∑Ô∏è Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://filpill.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://filpill.github.io/projects/">Projects</a></div>
    <h1 class="post-title">
      Flight Tracking Animations
    </h1>
    <div class="post-description">
      Retrieving airspace states via OpenSky REST API and animating data using Python &#43; FFMPEG
    </div>
    <div class="post-meta"><span title='2024-05-26 00:00:00 +0000 UTC'>May 26, 2024</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;1875 words

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://filpill.github.io/img/flight/airspace_visualiser.png" alt="">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#-summary" aria-label="üó∫Ô∏è Summary">üó∫Ô∏è Summary</a></li>
                <li>
                    <a href="#-data-processing-commentary" aria-label="üí¨ Data Processing Commentary">üí¨ Data Processing Commentary</a><ul>
                        
                <li>
                    <a href="#-overall-view" aria-label="üñºÔ∏è Overall View">üñºÔ∏è Overall View</a></li>
                <li>
                    <a href="#-procedural-timings" aria-label="‚è±Ô∏è Procedural Timings">‚è±Ô∏è Procedural Timings</a></li>
                <li>
                    <a href="#-data-collection" aria-label="üöú Data Collection">üöú Data Collection</a></li>
                <li>
                    <a href="#-data-visualisation" aria-label="üìä Data Visualisation">üìä Data Visualisation</a><ul>
                        
                <li>
                    <a href="#map-data-struggles" aria-label="Map Data Struggles">Map Data Struggles</a></li>
                <li>
                    <a href="#slow-color-mesh-plotting" aria-label="Slow Color Mesh Plotting">Slow Color Mesh Plotting</a></li></ul>
                </li>
                <li>
                    <a href="#-data-animation" aria-label="‚úàÔ∏è Data Animation">‚úàÔ∏è Data Animation</a></li>
                <li>
                    <a href="#-data-time-lapse" aria-label="üìΩÔ∏è Data Time-lapse">üìΩÔ∏è Data Time-lapse</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="-summary">üó∫Ô∏è Summary<a hidden class="anchor" aria-hidden="true" href="#-summary">#</a></h2>
<p>This article will quickly show you the process of obtaining airspace data using the OpenSky REST API and how I was able to visualise on a map. I will focus on North American airspace as it seems this region captures the highest volume of aircraft.</p>
<blockquote>
<p>The <a href="https://github.com/Filpill/flight_tracking">Flight Tracking GitHub Project link</a> is here should you wish to examine my scripts and get some context for the commentary in this article.</p>
</blockquote>
<p>The totality of the airspace depends on the maintenance of the OpenSky network. The majority of the data is recorded via ADS-B receivers, which are distributed over the land mass.</p>
<p><img loading="lazy" src="https://global.discourse-cdn.com/infiniteflight/original/4X/c/e/8/ce82d1b284d206ad24e395beaf56a63209fbee15.jpeg" alt="ADS-B Infographic"  />
</p>
<p>Regarding aircraft surveillance, I presume we lose visibility of aircraft (in the data) outside the range of ground stations such as the sea or mountainous terrain. Otherwise it would&rsquo;ve been interesting to monitor the full extent of flight paths across the globe.</p>
<p>Aircraft require a transponder to retrieve the GPS data i.e. communicating between satellites and ground stations. Any aircraft flying with no transponder are not captured in this view.</p>
<p>I am sure there are other flight data providers selling more accurate views and more reliable aircraft coverage, but this is purely an illustrative exercise for curiosities sake.</p>
<h2 id="-data-processing-commentary">üí¨ Data Processing Commentary<a hidden class="anchor" aria-hidden="true" href="#-data-processing-commentary">#</a></h2>
<p>I&rsquo;ll go through details of my data collection, storage and processing.</p>
<p>This was a fairly quick and dirty version, however, I still ensured a reasonable folder structure to manipulate the data in my workflow.</p>
<p>Long-term we can look at dumping this info into a SQLite or Postgres database.</p>
<h3 id="-overall-view">üñºÔ∏è Overall View<a hidden class="anchor" aria-hidden="true" href="#-overall-view">#</a></h3>
<p>The workflow looks something like this:</p>
<div style="text-align:center;">
	<div class="mermaid">
	  
graph LR;
    classDef blue fill:#2374f7,stroke:#8ec1f5,stroke-width:7px, color:#fff,stroke-dasharray: 4 1
    classDef yellow fill:#e6d00b,stroke:#f5eb5b,stroke-width:7px, color:#000,stroke-dasharray: 4 1
    classDef green fill:#10ad0a,stroke:#7feb4d,stroke-width:7px, color:#000,stroke-dasharray: 4 1
    classDef red fill:#db3b1f,stroke:#eb654d,stroke-width:7px, color:#fff,stroke-dasharray: 4 1

    1([Request aircraft positions]):::blue --o 2([Store raw csv]):::yellow--o3([Process images]):::green--o4([Create Video]):::red

    linkStyle 0 stroke:#8ec1f5,stroke-width:11px
    linkStyle 1 stroke:#f5eb5b,stroke-width:11px
    linkStyle 2 stroke:#7feb4d,stroke-width:11px

	</div>
</div>

<ol>
<li><span style="
      background-color:#8ec1f5;
      color:#000;
      padding:1px;
      border-radius:5px;
  ">
    API Request 
</span>
&nbsp;
 Every 60s for worldwide airspace snapshots.</li>
<li><span style="
      background-color:#f5eb5b;
      color:#000;
      padding:1px;
      border-radius:5px;
  ">
    Data Storage 
</span>
&nbsp;
 Dumping series of snapshots into timestamped csv&rsquo;s.</li>
<li><span style="
      background-color:#7feb4d;
      color:#000;
      padding:1px;
      border-radius:5px;
  ">
    Image Processing 
</span>
&nbsp;
 Read/prepare/filter data and draw visualisation onto map.</li>
<li><span style="
      background-color:#eb654d;
      color:#000;
      padding:1px;
      border-radius:5px;
  ">
    Animating 
</span>
&nbsp;
 Splice image collection with ffmpeg shell script</li>
</ol>
<h3 id="-procedural-timings">‚è±Ô∏è Procedural Timings<a hidden class="anchor" aria-hidden="true" href="#-procedural-timings">#</a></h3>
<p>To put some perspective in time required to process this data:</p>
<ul>
<li>It takes about <strong>16 hours to make 850 requests</strong> (@60s intervals).</li>
<li>It takes about <strong>5-10 mins to create all 850 image visualisations with quiver plot</strong>.</li>
<li>It takes about <strong>20 hours to create all 850 image visualisations with the KDE plot</strong>.
<ul>
<li><em>I&rsquo;m pretty sure the script slowed down over time. I was only removing the quiver artist but not the KDE artist (by omission). Probably too many chart element variables were being stored in the memory over time.</em></li>
</ul>
</li>
<li>Another <strong>4-7 mins to crops all the white space</strong> from the images.</li>
<li><strong>Splicing images takes about 3-5 ish mins</strong> into a neat .mp4.</li>
<li>And lastly the <strong>video edit takes around 30 mins</strong> to overlay music.</li>
</ul>
<p>All in all it roughly takes a full day with the PC running essentially non-stop. And I was manually driving the scripts since I didn&rsquo;t build any monitoring tools in this workflow.</p>
<h3 id="-data-collection">üöú Data Collection<a hidden class="anchor" aria-hidden="true" href="#-data-collection">#</a></h3>
<p>The goal here is simple: recursively request and store the aircraft positions in a list of timestamped csv&rsquo;s. This is how we will build our data repository.</p>
<p>We have to balance the time delta between each snapshot (API call); not too large to lose movement details and not too small to overload the API with requests. The latter is probably more important to consider, because we don&rsquo;t want to bombard the API and risk taking it completely out of commission with high frequency requests.</p>
<p>It&rsquo;s worth noting that that anonymous OpenSky API users are limited to 80 requests per day. This is no good for us since we are trying to make an extended time lapse over a period of time.</p>
<p>We can circumvent this issue through IP address rotation. Each API call will be distributed over a pool of IP addresses and thus prevent our request timing out (since they can&rsquo;t pin down our real identity).</p>
<p>This typically requires the use of a paid service to provide a set of high quality proxies. In my scenario, I chose to use <strong>OxyLabs</strong> which have a dedicated web scrapping proxy tool. You can route your Python request via the OxyLabs web-scrapping tool and it will automagically handle the proxies for you. I was able to run my script overnight with zero failures and retrieved over 850 requests.</p>
<p>Each request produces a 1.1MB csv file. Over the course of 16 hours, we were able to hoover about 1GB of data all together. Unfortunately, my script crashed in the late stages of the execution probably because I was running it out of a jupyter notebook and recursively printing output messages. Otherwise we could&rsquo;ve captured more. I&rsquo;ll convert it into a Python script eventually, it just so happens its easier to do data exploration in Jupyter.</p>
<p>You may notice also that the git history doesn&rsquo;t have an extensive list of csv data which because there is no reason to have a volume of csv&rsquo;s saved on the git history. Therefore it&rsquo;s simply added to the .gitignore and we are storing the files locally for the most part.</p>
<h3 id="-data-visualisation">üìä Data Visualisation<a hidden class="anchor" aria-hidden="true" href="#-data-visualisation">#</a></h3>
<p>I think the most interesting component to visualising this type of data is monitoring the density of air traffic at various times of day. Especially in North America where the time zone from east coast to west coast varies by a 6-hour difference. As the country approaches the early hours of the morning, the entire east coast essentially <em>&ldquo;go to sleep&rdquo;</em> with respect to the density of the traffic. Then it flips vice-versa as time progresses.</p>
<p>Additionally, we can see commercial flight routes and airport hubs where these flight networks are connecting each other. There is a multitude of ways to visualise this information, all the way from a contourf plot to a quiver plot to some kind of color mesh plot. Alternative 2D visualisations will reveal different information about air traffic behaviour, so it&rsquo;s good to compare and contrast.</p>
<p>Available GPS Data sourced from OpenSky API:</p>
<ul>
<li>Longitude</li>
<li>Latitude</li>
<li>Speed Bearing</li>
<li>Various other data points including callsigns.</li>
</ul>
<p>For a quiver plot, we need to split the speed into its horizontal and vertical components. We can do some basic trigonometry to figure that out.</p>
<p>In the quiver example below, we see the direction and speed (relative to it&rsquo;s arrow size) of each individual aircraft. When this data is animated, we can see the arrows get smaller for aircraft on the approach, and grow as they are taking off. It has a very interesting appearance.
<img loading="lazy" src="/img/flight/quiver_airspace.png" alt="Quiver Plot Airspace"  />
</p>
<p>We also can map this out is by creating a scatter distribution and embed the Gaussian KDE (Kernel Density Estimation) mapping onto the individual points themselves to get a feel for the distribution as there is a lot of overlap at this scale:</p>
<p><img loading="lazy" src="/img/flight/gaussian_scatter.png" alt="Gaussian Quiver Plot Airspace"  />
</p>
<p>And we can map the KDE over the entire map itself, however, we must create a &ldquo;meshgrid&rdquo; over the plot. The aircraft exist between the grids native resolution, therefore we would need to re-shape the data into a 2-dimensional array containing the aircraft density distribution.</p>
<p>We can combine the 2D KDE mapping with the quiver plot to reveal a bit more information on aircraft density distribution, like so:</p>
<p><img loading="lazy" src="/img/flight/gaussian_quiver.png" alt="Gaussian Quiver Plot Airspace"  />
</p>
<p>The plotting process is iterated over the folder of timestamped csv&rsquo;s to generate the incremental aircraft movements over time.</p>
<h4 id="map-data-struggles">Map Data Struggles<a hidden class="anchor" aria-hidden="true" href="#map-data-struggles">#</a></h4>
<p>Something that left me completely stumped for a while is that I was not able to directly use the Stadia Maps API within in <strong>Cartopy 0.22.0</strong> which was confusing and frustrating.</p>
<p>I chose to use the <strong>Stadia Maps</strong> API via the Cartopy as it had already build the classes to plug into the API and it had a high contrast map tile that thought was suitable. <strong>But it doesn&rsquo;t work on Cartopy 0.22.0&hellip;</strong> It really was a head scratcher for me. After reading the site-packages I realised that the API class I was using was completely defunct within a matter of months.</p>
<p>Although, I discovered a <strong>revised class object sitting (which works) in Cartopy 0.23.0</strong> which was unavailable as a wheel/conda package. So, this was the first time I had to go <strong>build the package from source in the git repo</strong> just for this specific use case. But when they eventually package the final version of 0.23.0 in conda, this issue will no longer be the case&hellip;</p>
<p>Although I came across some issues since each API call for the mapping data costs credits to use. And since the map is completely static, it doesn&rsquo;t make sense to make multiple API calls for each set of data from a cost perspective.</p>
<p>Even from a time perspective, it takes a very long time to render the map, about 13s for each snapshot which is way too long. Instead, the process I have created is to only clear the relevant &ldquo;artists&rdquo; on the matplotlib figure whilst retaining the map image on the plot. So we can save a lot of time.</p>
<p>Plotting the scatterpoints takes a trivial amount of time in comparison, about 1-2s or so per iteration.</p>
<h4 id="slow-color-mesh-plotting">Slow Color Mesh Plotting<a hidden class="anchor" aria-hidden="true" href="#slow-color-mesh-plotting">#</a></h4>
<p>Plotting the 2D Gaussian KDE plot was much more intensive as we are drawing a high resolution color mapping across the entire grid. Each iteration was about 20-25s to render but it tended to slow down to over 1m per iteration. The filled color grid mapping took about 20 hours to create all 850 images. Probably because I was not removing the artist itself per iteration, but this is just a working assumption. I&rsquo;ll have a look at optimising in the future.</p>
<p>Bearing in mind we are purely talking about <strong>single core processing</strong>. Splitting the load across the rest of the CPU cores, and spawning the data processes in parallel would&rsquo;ve cut the time significantly. I&rsquo;ll investigate this setup in the near future to optimise the compute power since Python is pretty slow in general.</p>
<h3 id="-data-animation">‚úàÔ∏è Data Animation<a hidden class="anchor" aria-hidden="true" href="#-data-animation">#</a></h3>
<p>This is the key component where we can physically see how the aircraft are moving over time.</p>
<p>This animation procedure is fairly straightforward when using <strong>ffmpeg</strong> in a bash script. We can point to a folder with a collection of images and ask the program to splice them together into a mp4 file (or whatever file type).</p>
<p>Assuming the images are timestamped, the files should be sorted in chronological order so you don&rsquo;t need to fiddle with passing additional sort arguments into your command.</p>
<p>It only takes a few minutes on my machine to splice together 850 images together.</p>
<p>My file structure is segmented into multiple folders partitioned by &ldquo;date&rdquo; and &ldquo;visualisation type&rdquo;, I simply pass those parameters into my bash script to generate the spliced video.</p>
<p>The script is only a few lines and looks like this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e">#!/bin/sh
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#75715e"># $1 Specifies the Date of the folder to be accessed - E.g. &#39;2024-08-24&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># $2 Specifies the Image Folder To Be Accessed - E.g. &#39;scatter&#39; or &#39;quiver&#39; or &#39;contourf&#39;</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example of how to run bash script: $(./mkvideo &#39;2024-08-24&#39; &#39;scatter&#39;)</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>base_folder<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>dirname <span style="color:#66d9ef">$(</span>pwd<span style="color:#66d9ef">))</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>output<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$base_folder<span style="color:#e6db74">/animate/videos&#34;</span>
</span></span><span style="display:flex;"><span>image_data<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;</span>$base_folder<span style="color:#e6db74">/data/get_states/</span>$1<span style="color:#e6db74">/</span>$2<span style="color:#e6db74">/crop&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>ffmpeg -framerate <span style="color:#ae81ff">24</span> -pattern_type glob -i <span style="color:#e6db74">&#34;</span><span style="color:#e6db74">${</span>image_data<span style="color:#e6db74">}</span><span style="color:#e6db74">/*.png&#34;</span> $output/$1_$2_movements.mp4
</span></span></code></pre></div><p>Other video processing was down on Kdenlive to add in the musical audio transitions.</p>
<h3 id="-data-time-lapse">üìΩÔ∏è Data Time-lapse<a hidden class="anchor" aria-hidden="true" href="#-data-time-lapse">#</a></h3>
<p>Videos illustrating the 16-hour scatter plot time-lapse of aircraft flying over North America.


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/wC3WE-jOU0w?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>



    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/RLNOIJgDLgw?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>
</p>



  </div>


  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://filpill.github.io/tags/-data/">üìä Data</a></li>
    </ul>
<nav class="paginav">
  <a class="next" href="https://filpill.github.io/projects/2024-04-16-wireguard-vpn/">
    <span class="title">Next ¬ª</span>
    <br>
    <span>WireGuard VPN Server</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://filpill.github.io/">Filip Livancic</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
